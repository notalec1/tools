<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>OpenFlipchart - Phase 1</title>
    <!-- Fabric.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <!-- Icons -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    
    <style>
        /* =========================================
           1. CSS STYLES
           ========================================= */
        :root {
            --bg-dark: #2c3e50;
            --bg-panel: #ecf0f1;
            --bg-canvas: #95a5a6;
            --accent: #e67e22;
            --accent-hover: #d35400;
            --text-main: #2c3e50;
            --border: #bdc3c7;
            --header-height: 50px;
            --sidebar-width: 200px;
        }

        * { box-sizing: border-box; user-select: none; }

        body, html {
            width: 100%; height: 100%; margin: 0; padding: 0;
            font-family: 'Segoe UI', sans-serif;
            background-color: var(--bg-dark);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        header {
            height: var(--header-height);
            background: #34495e;
            color: white;
            display: flex;
            align-items: center;
            padding: 0 15px;
            justify-content: space-between;
            border-bottom: 1px solid #2c3e50;
            z-index: 10;
        }

        .brand { font-weight: bold; font-size: 1.2rem; display: flex; align-items: center; gap: 10px; }
        .menu-actions { display: flex; gap: 10px; }

        /* Main Container */
        #app-container {
            display: flex;
            flex: 1;
            height: calc(100% - var(--header-height));
            position: relative;
        }

        /* Sidebar */
        #sidebar {
            width: var(--sidebar-width);
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 10px;
            overflow-y: auto;
        }

        .page-thumbnail {
            width: 100%;
            height: 110px;
            background: white;
            border: 3px solid transparent;
            margin-bottom: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            cursor: pointer;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: #ccc;
        }

        .page-thumbnail.active { border-color: var(--accent); }
        .page-number {
            position: absolute; bottom: 5px; right: 5px;
            font-size: 0.8rem; background: rgba(0,0,0,0.6);
            color: white; padding: 2px 6px; border-radius: 4px;
        }

        #add-page-btn {
            width: 100%; padding: 10px; background: var(--accent);
            color: white; border: none; border-radius: 4px;
            cursor: pointer; font-weight: bold; margin-bottom: 10px;
        }

        /* Canvas Stage */
        #canvas-stage {
            flex: 1;
            background-color: var(--bg-canvas);
            position: relative;
            overflow: hidden;
            /* Center the canvas visually if needed, usually we fill 100% though */
        }

        /* Floating Toolbar */
        #main-toolbar {
            position: absolute;
            top: 20px; right: 20px;
            width: 50px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            padding: 10px 0;
            display: flex; flex-direction: column;
            align-items: center; gap: 5px;
            z-index: 100;
        }

        .tool-btn {
            width: 40px; height: 40px;
            border: none; background: transparent;
            border-radius: 6px; cursor: pointer;
            color: var(--text-main); font-size: 1.1rem;
            transition: all 0.2s;
        }

        .tool-btn:hover { background: #dfe6e9; }
        .tool-btn.active { background: #ffeaa7; color: #d35400; border: 2px solid var(--accent); }

        /* Properties Bar */
        #properties-bar {
            position: absolute; bottom: 20px; left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 8px 20px;
            border-radius: 50px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            display: flex; align-items: center; gap: 15px;
            z-index: 100;
        }

        .color-swatch {
            width: 24px; height: 24px; border-radius: 50%;
            cursor: pointer; border: 2px solid rgba(0,0,0,0.1);
        }
        .color-swatch.active { transform: scale(1.3); border-color: #333; }

        .divider { width: 1px; height: 20px; background: #ddd; }
        
        .btn-primary {
            background: var(--accent); color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer;
        }

    </style>
</head>
<body>

    <!-- Header -->
    <header>
        <div class="brand"><i class="fas fa-chalkboard-teacher"></i> OpenFlipchart</div>
        <div class="menu-actions">
            <button class="btn-primary" id="btn-import">Import</button>
            <button class="btn-primary" id="btn-export">Save</button>
            <input type="file" id="file-input" hidden accept=".json">
        </div>
    </header>

    <div id="app-container">
        
        <!-- Sidebar -->
        <div id="sidebar">
            <button id="add-page-btn">+ New Page</button>
            <div id="page-list"></div>
        </div>

        <!-- Stage -->
        <div id="canvas-stage">
            <canvas id="c"></canvas>
        </div>

        <!-- Tools -->
        <div id="main-toolbar">
            <button class="tool-btn active" id="tool-select" title="Select (V)"><i class="fas fa-mouse-pointer"></i></button>
            <button class="tool-btn" id="tool-pen" title="Pen (P)"><i class="fas fa-pen"></i></button>
            <button class="tool-btn" id="tool-highlighter" title="Highlighter"><i class="fas fa-highlighter"></i></button>
            <button class="tool-btn" id="tool-eraser" title="Eraser (E)"><i class="fas fa-eraser"></i></button>
            <div style="height:1px; width:30px; background:#ddd; margin: 5px 0;"></div>
            <button class="tool-btn" id="tool-rect" title="Rectangle"><i class="far fa-square"></i></button>
            <button class="tool-btn" id="tool-circle" title="Circle"><i class="far fa-circle"></i></button>
            <button class="tool-btn" id="tool-text" title="Text (T)"><i class="fas fa-font"></i></button>
            <div style="height:1px; width:30px; background:#ddd; margin: 5px 0;"></div>
            <button class="tool-btn" id="tool-undo" title="Undo (Ctrl+Z)"><i class="fas fa-undo"></i></button>
            <button class="tool-btn" id="tool-redo" title="Redo (Ctrl+Y)"><i class="fas fa-redo"></i></button>
            <button class="tool-btn" id="tool-clear" title="Clear Page"><i class="fas fa-trash-alt"></i></button>
        </div>

        <!-- Properties -->
        <div id="properties-bar">
            <!-- Colors -->
            <div class="color-swatch active" style="background: #000000;" data-color="#000000"></div>
            <div class="color-swatch" style="background: #e74c3c;" data-color="#e74c3c"></div>
            <div class="color-swatch" style="background: #3498db;" data-color="#3498db"></div>
            <div class="color-swatch" style="background: #2ecc71;" data-color="#2ecc71"></div>
            <div class="color-swatch" style="background: #f1c40f;" data-color="#f1c40f"></div>
            
            <div class="divider"></div>
            
            <!-- Size -->
            <i class="fas fa-circle" style="font-size: 0.5rem; color: #7f8c8d;"></i>
            <input type="range" id="size-slider" min="1" max="50" value="3" style="width:100px;">
            <i class="fas fa-circle" style="font-size: 1.2rem; color: #7f8c8d;"></i>
            
            <div class="divider"></div>

            <!-- Backgrounds -->
            <select id="bg-select" style="padding: 5px; border-radius:4px; border:1px solid #ccc;">
                <option value="white">White</option>
                <option value="grid">Grid</option>
                <option value="lines">Lined</option>
                <option value="blue">Promethean Blue</option>
            </select>
        </div>
    </div>

    <!-- =========================================
         2. LOGIC
         ========================================= -->
    <script>
    class WhiteboardApp {
        constructor() {
            this.canvas = null;
            this.pages = []; 
            this.currentPageIndex = 0;
            
            // History Stacks
            this.undoStack = [];
            this.redoStack = [];
            this.historyProcessing = false; // Lock to prevent loops
            
            // App State
            this.currentMode = 'select'; 
            this.currentColor = '#000000';
            this.currentSize = 3;

            this.init();
        }

        init() {
            // Setup Fabric
            this.canvas = new fabric.Canvas('c', {
                isDrawingMode: false,
                backgroundColor: '#ffffff',
                selection: true,
                preserveObjectStacking: true
            });

            // Make Canvas Responsive
            this.setupResponsiveCanvas();

            // Bind Events (Clicks, Keys)
            this.bindEvents();
            
            // Bind Canvas History Events
            this.bindHistoryEvents();

            // Initialize Page 1
            this.addNewPage();

            // Default to Pen
            this.setTool('pen');
        }

        /* ==========================
           HISTORY SYSTEM (UNDO/REDO)
           ========================== */
        
        saveState() {
            if(this.historyProcessing) return;
            
            // Limit stack size to 50 to prevent memory issues
            if (this.undoStack.length > 50) this.undoStack.shift();
            
            // Push current JSON to stack
            this.undoStack.push(JSON.stringify(this.canvas.toJSON()));
            
            // Clear Redo stack on new action
            this.redoStack = [];
        }

        undo() {
            if (this.undoStack.length === 0) return;
            
            this.historyProcessing = true;
            
            // 1. Push current state to Redo
            this.redoStack.push(JSON.stringify(this.canvas.toJSON()));
            
            // 2. Pop previous state
            const prevState = this.undoStack.pop();
            
            // 3. Load it
            this.canvas.loadFromJSON(prevState, () => {
                this.canvas.renderAll();
                this.historyProcessing = false;
                
                // Re-apply brush settings because loadFromJSON resets them
                this.updateBrushSettings(); 
            });
        }

        redo() {
            if (this.redoStack.length === 0) return;
            
            this.historyProcessing = true;
            
            // 1. Push current to Undo
            this.undoStack.push(JSON.stringify(this.canvas.toJSON()));
            
            // 2. Pop next state
            const nextState = this.redoStack.pop();
            
            // 3. Load it
            this.canvas.loadFromJSON(nextState, () => {
                this.canvas.renderAll();
                this.historyProcessing = false;
                this.updateBrushSettings();
            });
        }

        bindHistoryEvents() {
            // Save state on any modification
            this.canvas.on('object:added', () => this.saveState());
            this.canvas.on('object:modified', () => this.saveState());
            this.canvas.on('object:removed', () => this.saveState());
            // Note: path:created triggers object:added, so we are covered for drawing
        }

        /* ==========================
           CANVAS & TOOLS
           ========================== */

        setupResponsiveCanvas() {
            const stage = document.getElementById('canvas-stage');
            const resize = () => {
                this.canvas.setWidth(stage.clientWidth);
                this.canvas.setHeight(stage.clientHeight);
                this.canvas.renderAll();
                this.updateBackground();
            };
            new ResizeObserver(resize).observe(stage);
        }

        setTool(mode) {
            // Visual Update
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById(`tool-${mode}`);
            if(btn) btn.classList.add('active');

            this.currentMode = mode;
            this.canvas.isDrawingMode = false;
            this.canvas.selection = true;
            this.canvas.defaultCursor = 'default';
            this.canvas.off('mouse:down'); // Remove shape listeners

            if (mode === 'pen' || mode === 'highlighter') {
                this.canvas.isDrawingMode = true;
                this.canvas.selection = false;
                this.updateBrushSettings(); // Set color/width
            } 
            else if (mode === 'eraser') {
                this.canvas.isDrawingMode = true;
                this.canvas.freeDrawingBrush = new fabric.PencilBrush(this.canvas);
                this.canvas.freeDrawingBrush.color = '#ffffff'; 
                this.canvas.freeDrawingBrush.width = 30;
            }
            else if (mode === 'rect' || mode === 'circle') {
                this.canvas.selection = false;
                this.canvas.defaultCursor = 'crosshair';
                this.setupShapeDrawer(mode);
            }
        }

        updateBrushSettings() {
            // Used to re-apply pen settings after Undo/Redo or Color Change
            if (!this.canvas.freeDrawingBrush) return;

            if (this.currentMode === 'pen') {
                this.canvas.freeDrawingBrush = new fabric.PencilBrush(this.canvas);
                this.canvas.freeDrawingBrush.color = this.currentColor;
                this.canvas.freeDrawingBrush.width = parseInt(this.currentSize, 10);
                // Decimate creates smoother lines by ignoring points closer than 2.5px
                this.canvas.freeDrawingBrush.decimate = 2.5; 
            } 
            else if (this.currentMode === 'highlighter') {
                this.canvas.freeDrawingBrush = new fabric.PencilBrush(this.canvas);
                const c = new fabric.Color(this.currentColor);
                this.canvas.freeDrawingBrush.color = c.setAlpha(0.3).toRgba();
                this.canvas.freeDrawingBrush.width = parseInt(this.currentSize, 10) * 3;
                this.canvas.freeDrawingBrush.decimate = 2.5;
            }
        }

        setupShapeDrawer(type) {
            let rect, isDown, origX, origY;
            
            this.canvas.on('mouse:down', (o) => {
                isDown = true;
                const pointer = this.canvas.getPointer(o.e);
                origX = pointer.x; origY = pointer.y;
                
                if (type === 'rect') {
                    rect = new fabric.Rect({
                        left: origX, top: origY, width: 0, height: 0,
                        fill: this.currentColor, strokeWidth: 0
                    });
                } else {
                    rect = new fabric.Circle({
                        left: origX, top: origY, radius: 1,
                        fill: this.currentColor, originX: 'left', originY: 'top'
                    });
                }
                this.canvas.add(rect);
            });

            this.canvas.on('mouse:move', (o) => {
                if (!isDown) return;
                const pointer = this.canvas.getPointer(o.e);
                if (type === 'rect') {
                    if (origX > pointer.x) rect.set({ left: Math.abs(pointer.x) });
                    if (origY > pointer.y) rect.set({ top: Math.abs(pointer.y) });
                    rect.set({ width: Math.abs(origX - pointer.x), height: Math.abs(origY - pointer.y) });
                } else {
                    const radius = Math.abs(origX - pointer.x) / 2;
                    rect.set({ radius: radius });
                }
                this.canvas.renderAll();
            });

            this.canvas.on('mouse:up', () => {
                isDown = false;
                rect.setCoords();
                this.saveState(); // Explicit save for shapes
                this.setTool('select'); // Auto-revert
            });
        }

        /* ==========================
           PAGE MANAGEMENT
           ========================== */
        
        saveCurrentPage() {
            this.pages[this.currentPageIndex] = this.canvas.toJSON();
        }

        loadPage(index) {
            this.saveCurrentPage(); // Save old
            this.currentPageIndex = index;
            
            this.canvas.loadFromJSON(this.pages[index], () => {
                this.canvas.renderAll();
                this.updateUIForPage();
                // Reset history for new page? Or keep it?
                // Usually easier to reset history per page for now
                this.undoStack = []; 
                this.redoStack = [];
                // Ensure tool is consistent
                this.setTool(this.currentMode);
            });
        }

        addNewPage() {
            if (this.pages.length > 0) this.saveCurrentPage();
            const blank = { version: "5.3.0", objects: [], background: "#ffffff" };
            this.pages.push(blank);
            this.renderPageList();
            this.loadPage(this.pages.length - 1);
        }

        renderPageList() {
            const list = document.getElementById('page-list');
            list.innerHTML = '';
            this.pages.forEach((p, i) => {
                const div = document.createElement('div');
                div.className = `page-thumbnail ${i === this.currentPageIndex ? 'active' : ''}`;
                div.innerHTML = `<i class="far fa-file"></i><span class="page-number">${i+1}</span>`;
                div.onclick = () => this.loadPage(i);
                list.appendChild(div);
            });
        }

        updateUIForPage() {
            const thumbs = document.querySelectorAll('.page-thumbnail');
            thumbs.forEach((t, i) => {
                if (i === this.currentPageIndex) t.classList.add('active');
                else t.classList.remove('active');
            });
            this.updateBackground();
        }

        updateBackground() {
            // Helper to redraw grid if needed (not fully implemented in this snippet for brevity, 
            // but structure is here)
             const val = document.getElementById('bg-select').value;
             this.setBackground(val);
        }

        setBackground(type) {
            this.canvas.setBackgroundColor('#ffffff', this.canvas.renderAll.bind(this.canvas));
            if (type === 'blue') {
                this.canvas.setBackgroundColor('#81ecec', this.canvas.renderAll.bind(this.canvas));
            } else if (type === 'grid') {
                // simple grid logic
                const patternCanvas = document.createElement('canvas');
                patternCanvas.width = 40; patternCanvas.height = 40;
                const ctx = patternCanvas.getContext('2d');
                ctx.strokeStyle = '#eee'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(40,0); ctx.moveTo(0,0); ctx.lineTo(0,40); ctx.stroke();
                const pattern = new fabric.Pattern({ source: patternCanvas, repeat: 'repeat' });
                this.canvas.setBackgroundColor(pattern, this.canvas.renderAll.bind(this.canvas));
            }
        }

        /* ==========================
           INPUT BINDING
           ========================== */
        
        bindEvents() {
            // Tool Buttons
            ['select','pen','highlighter','eraser','rect','circle'].forEach(t => {
                document.getElementById(`tool-${t}`).onclick = () => this.setTool(t);
            });

            document.getElementById('tool-text').onclick = () => {
                const text = new fabric.IText('Text', { 
                    left: 200, top: 200, fill: this.currentColor, fontSize: 40 
                });
                this.canvas.add(text);
                this.canvas.setActiveObject(text);
                this.setTool('select');
            };

            // Undo/Redo/Clear Buttons
            document.getElementById('tool-undo').onclick = () => this.undo();
            document.getElementById('tool-redo').onclick = () => this.redo();
            document.getElementById('tool-clear').onclick = () => {
                if(confirm('Clear Page?')) { 
                    this.canvas.clear(); 
                    this.saveState(); // Clearing is a state change
                    this.updateBackground();
                }
            };

            // Color Picker (BUG FIX IMPLEMENTED)
            document.querySelectorAll('.color-swatch').forEach(swatch => {
                swatch.onclick = (e) => {
                    // UI
                    document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                    e.target.classList.add('active');
                    
                    // Logic
                    this.currentColor = e.target.getAttribute('data-color');
                    
                    // Apply to selection
                    const active = this.canvas.getActiveObject();
                    if (active) {
                        active.set({ fill: this.currentColor });
                        if (active.type === 'path') active.set({ stroke: this.currentColor });
                        this.canvas.renderAll();
                        this.saveState();
                    }

                    // Keep Pen Active & Updated
                    if (this.currentMode === 'pen' || this.currentMode === 'highlighter') {
                        this.canvas.isDrawingMode = true; // Ensure mode stays
                        this.updateBrushSettings();       // Apply new color
                    }
                };
            });

            // Size Slider
            document.getElementById('size-slider').addEventListener('input', (e) => {
                this.currentSize = e.target.value;
                this.updateBrushSettings();
            });
            
            // Background
            document.getElementById('bg-select').addEventListener('change', (e) => this.setBackground(e.target.value));

            // Sidebar
            document.getElementById('add-page-btn').onclick = () => this.addNewPage();

            // Keyboard Shortcuts
            document.addEventListener('keydown', (e) => {
                // Undo/Redo
                if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); this.undo(); }
                if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); this.redo(); }
                
                // Delete
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    const active = this.canvas.getActiveObjects();
                    if (active.length && !this.canvas.isDrawingMode) {
                        this.canvas.discardActiveObject();
                        active.forEach(obj => this.canvas.remove(obj));
                        this.saveState();
                    }
                }
            });

            // File Export/Import
            document.getElementById('btn-export').onclick = () => {
                this.saveCurrentPage();
                const blob = new Blob([JSON.stringify({version:"1.0", pages:this.pages})], {type:"application/json"});
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = "lesson.json";
                a.click();
            };
            
            const fIn = document.getElementById('file-input');
            document.getElementById('btn-import').onclick = () => fIn.click();
            fIn.onchange = (e) => {
                const r = new FileReader();
                r.onload = (res) => {
                    try {
                        const data = JSON.parse(res.target.result);
                        if(data.pages) {
                            this.pages = data.pages;
                            this.currentPageIndex = 0;
                            this.renderPageList();
                            this.loadPage(0);
                        }
                    } catch(err){ alert("Error loading file"); }
                };
                if(e.target.files[0]) r.readAsText(e.target.files[0]);
                e.target.value = '';
            };
        }
    }

    // Bootstrap
    window.onload = () => window.app = new WhiteboardApp();
    </script>
</body>
</html>
